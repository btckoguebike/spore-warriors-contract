// Generated by Molecule 0.7.5

use super::types::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct Effect(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Effect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Effect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Effect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "trigger", self.trigger())?;
        write!(f, ", {}: {}", "execution", self.execution())?;
        write!(f, ", {}: {}", "discard", self.discard())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Effect {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Effect::new_unchecked(v)
    }
}
impl Effect {
    const DEFAULT_VALUE: [u8; 22] = [
        22, 0, 0, 0, 20, 0, 0, 0, 22, 0, 0, 0, 22, 0, 0, 0, 22, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceId {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceId::new_unchecked(self.0.slice(start..end))
    }
    pub fn trigger(&self) -> ContextOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ContextOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn execution(&self) -> ContextOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ContextOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn discard(&self) -> ContextOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            ContextOpt::new_unchecked(self.0.slice(start..end))
        } else {
            ContextOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> EffectReader<'r> {
        EffectReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Effect {
    type Builder = EffectBuilder;
    const NAME: &'static str = "Effect";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Effect(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EffectReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EffectReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .id(self.id())
            .trigger(self.trigger())
            .execution(self.execution())
            .discard(self.discard())
    }
}
#[derive(Clone, Copy)]
pub struct EffectReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for EffectReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for EffectReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for EffectReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "trigger", self.trigger())?;
        write!(f, ", {}: {}", "execution", self.execution())?;
        write!(f, ", {}: {}", "discard", self.discard())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> EffectReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceIdReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceIdReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn trigger(&self) -> ContextOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ContextOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn execution(&self) -> ContextOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ContextOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn discard(&self) -> ContextOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            ContextOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ContextOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for EffectReader<'r> {
    type Entity = Effect;
    const NAME: &'static str = "EffectReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        EffectReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ResourceIdReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ContextOptReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ContextOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        ContextOptReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct EffectBuilder {
    pub(crate) id: ResourceId,
    pub(crate) trigger: ContextOpt,
    pub(crate) execution: ContextOpt,
    pub(crate) discard: ContextOpt,
}
impl EffectBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn id(mut self, v: ResourceId) -> Self {
        self.id = v;
        self
    }
    pub fn trigger(mut self, v: ContextOpt) -> Self {
        self.trigger = v;
        self
    }
    pub fn execution(mut self, v: ContextOpt) -> Self {
        self.execution = v;
        self
    }
    pub fn discard(mut self, v: ContextOpt) -> Self {
        self.discard = v;
        self
    }
}
impl molecule::prelude::Builder for EffectBuilder {
    type Entity = Effect;
    const NAME: &'static str = "EffectBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.trigger.as_slice().len()
            + self.execution.as_slice().len()
            + self.discard.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.trigger.as_slice().len();
        offsets.push(total_size);
        total_size += self.execution.as_slice().len();
        offsets.push(total_size);
        total_size += self.discard.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.trigger.as_slice())?;
        writer.write_all(self.execution.as_slice())?;
        writer.write_all(self.discard.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Effect::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct EffectVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for EffectVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for EffectVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for EffectVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for EffectVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        EffectVec::new_unchecked(v)
    }
}
impl EffectVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Effect> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Effect {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Effect::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Effect::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> EffectVecReader<'r> {
        EffectVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for EffectVec {
    type Builder = EffectVecBuilder;
    const NAME: &'static str = "EffectVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        EffectVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EffectVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EffectVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct EffectVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for EffectVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for EffectVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for EffectVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> EffectVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<EffectReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> EffectReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            EffectReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            EffectReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for EffectVecReader<'r> {
    type Entity = EffectVec;
    const NAME: &'static str = "EffectVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        EffectVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            EffectReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct EffectVecBuilder(pub(crate) Vec<Effect>);
impl EffectVecBuilder {
    pub fn set(mut self, v: Vec<Effect>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Effect) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Effect>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Effect) -> Option<Effect> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for EffectVecBuilder {
    type Entity = EffectVec;
    const NAME: &'static str = "EffectVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        EffectVec::new_unchecked(inner.into())
    }
}
pub struct EffectVecIterator(EffectVec, usize, usize);
impl ::core::iter::Iterator for EffectVecIterator {
    type Item = Effect;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for EffectVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for EffectVec {
    type Item = Effect;
    type IntoIter = EffectVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        EffectVecIterator(self, 0, len)
    }
}
impl<'r> EffectVecReader<'r> {
    pub fn iter<'t>(&'t self) -> EffectVecReaderIterator<'t, 'r> {
        EffectVecReaderIterator(&self, 0, self.len())
    }
}
pub struct EffectVecReaderIterator<'t, 'r>(&'t EffectVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for EffectVecReaderIterator<'t, 'r> {
    type Item = EffectReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for EffectVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Card(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Card {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Card {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Card {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "class", self.class())?;
        write!(f, ", {}: {}", "cost", self.cost())?;
        write!(f, ", {}: {}", "price", self.price())?;
        write!(f, ", {}: {}", "effect_pool", self.effect_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Card {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Card::new_unchecked(v)
    }
}
impl Card {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 24, 0, 0, 0, 26, 0, 0, 0, 27, 0, 0, 0, 28, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0,
        16, 0, 0, 0, 12, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceId {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceId::new_unchecked(self.0.slice(start..end))
    }
    pub fn class(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn cost(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn price(&self) -> RandomNumber {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomNumber::new_unchecked(self.0.slice(start..end))
    }
    pub fn effect_pool(&self) -> ResourceIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            ResourceIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ResourceIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CardReader<'r> {
        CardReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Card {
    type Builder = CardBuilder;
    const NAME: &'static str = "Card";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Card(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CardReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CardReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .id(self.id())
            .class(self.class())
            .cost(self.cost())
            .price(self.price())
            .effect_pool(self.effect_pool())
    }
}
#[derive(Clone, Copy)]
pub struct CardReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CardReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CardReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CardReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "class", self.class())?;
        write!(f, ", {}: {}", "cost", self.cost())?;
        write!(f, ", {}: {}", "price", self.price())?;
        write!(f, ", {}: {}", "effect_pool", self.effect_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CardReader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceIdReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceIdReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn class(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cost(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn price(&self) -> RandomNumberReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomNumberReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn effect_pool(&self) -> ResourceIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CardReader<'r> {
    type Entity = Card;
    const NAME: &'static str = "CardReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CardReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ResourceIdReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ByteReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        RandomNumberReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ResourceIdVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct CardBuilder {
    pub(crate) id: ResourceId,
    pub(crate) class: Byte,
    pub(crate) cost: Byte,
    pub(crate) price: RandomNumber,
    pub(crate) effect_pool: ResourceIdVec,
}
impl CardBuilder {
    pub const FIELD_COUNT: usize = 5;
    pub fn id(mut self, v: ResourceId) -> Self {
        self.id = v;
        self
    }
    pub fn class(mut self, v: Byte) -> Self {
        self.class = v;
        self
    }
    pub fn cost(mut self, v: Byte) -> Self {
        self.cost = v;
        self
    }
    pub fn price(mut self, v: RandomNumber) -> Self {
        self.price = v;
        self
    }
    pub fn effect_pool(mut self, v: ResourceIdVec) -> Self {
        self.effect_pool = v;
        self
    }
}
impl molecule::prelude::Builder for CardBuilder {
    type Entity = Card;
    const NAME: &'static str = "CardBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.class.as_slice().len()
            + self.cost.as_slice().len()
            + self.price.as_slice().len()
            + self.effect_pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.class.as_slice().len();
        offsets.push(total_size);
        total_size += self.cost.as_slice().len();
        offsets.push(total_size);
        total_size += self.price.as_slice().len();
        offsets.push(total_size);
        total_size += self.effect_pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.class.as_slice())?;
        writer.write_all(self.cost.as_slice())?;
        writer.write_all(self.price.as_slice())?;
        writer.write_all(self.effect_pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Card::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CardVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CardVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CardVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CardVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for CardVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CardVec::new_unchecked(v)
    }
}
impl CardVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Card> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Card {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Card::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Card::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CardVecReader<'r> {
        CardVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CardVec {
    type Builder = CardVecBuilder;
    const NAME: &'static str = "CardVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CardVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CardVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CardVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct CardVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CardVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CardVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CardVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> CardVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<CardReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> CardReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            CardReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            CardReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CardVecReader<'r> {
    type Entity = CardVec;
    const NAME: &'static str = "CardVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CardVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            CardReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct CardVecBuilder(pub(crate) Vec<Card>);
impl CardVecBuilder {
    pub fn set(mut self, v: Vec<Card>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Card) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Card>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Card) -> Option<Card> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for CardVecBuilder {
    type Entity = CardVec;
    const NAME: &'static str = "CardVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CardVec::new_unchecked(inner.into())
    }
}
pub struct CardVecIterator(CardVec, usize, usize);
impl ::core::iter::Iterator for CardVecIterator {
    type Item = Card;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for CardVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for CardVec {
    type Item = Card;
    type IntoIter = CardVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        CardVecIterator(self, 0, len)
    }
}
impl<'r> CardVecReader<'r> {
    pub fn iter<'t>(&'t self) -> CardVecReaderIterator<'t, 'r> {
        CardVecReaderIterator(&self, 0, self.len())
    }
}
pub struct CardVecReaderIterator<'t, 'r>(&'t CardVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for CardVecReaderIterator<'t, 'r> {
    type Item = CardReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for CardVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Item(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Item {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Item {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Item {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "class", self.class())?;
        write!(f, ", {}: {}", "quality", self.quality())?;
        write!(f, ", {}: {}", "random_weight", self.random_weight())?;
        write!(f, ", {}: {}", "price", self.price())?;
        write!(f, ", {}: {}", "effect_pool", self.effect_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Item {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Item::new_unchecked(v)
    }
}
impl Item {
    const DEFAULT_VALUE: [u8; 66] = [
        66, 0, 0, 0, 28, 0, 0, 0, 30, 0, 0, 0, 31, 0, 0, 0, 32, 0, 0, 0, 46, 0, 0, 0, 62, 0, 0, 0,
        0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 16, 0, 0, 0, 12, 0, 0, 0, 14, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceId {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceId::new_unchecked(self.0.slice(start..end))
    }
    pub fn class(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn quality(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn random_weight(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn price(&self) -> RandomNumber {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        RandomNumber::new_unchecked(self.0.slice(start..end))
    }
    pub fn effect_pool(&self) -> ResourceIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            ResourceIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ResourceIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ItemReader<'r> {
        ItemReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Item {
    type Builder = ItemBuilder;
    const NAME: &'static str = "Item";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Item(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ItemReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ItemReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .id(self.id())
            .class(self.class())
            .quality(self.quality())
            .random_weight(self.random_weight())
            .price(self.price())
            .effect_pool(self.effect_pool())
    }
}
#[derive(Clone, Copy)]
pub struct ItemReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ItemReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ItemReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ItemReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "class", self.class())?;
        write!(f, ", {}: {}", "quality", self.quality())?;
        write!(f, ", {}: {}", "random_weight", self.random_weight())?;
        write!(f, ", {}: {}", "price", self.price())?;
        write!(f, ", {}: {}", "effect_pool", self.effect_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ItemReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceIdReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceIdReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn class(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn quality(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn random_weight(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn price(&self) -> RandomNumberReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        RandomNumberReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn effect_pool(&self) -> ResourceIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ItemReader<'r> {
    type Entity = Item;
    const NAME: &'static str = "ItemReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ItemReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ResourceIdReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ByteReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        RandomByteReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        RandomNumberReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        ResourceIdVecReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ItemBuilder {
    pub(crate) id: ResourceId,
    pub(crate) class: Byte,
    pub(crate) quality: Byte,
    pub(crate) random_weight: RandomByte,
    pub(crate) price: RandomNumber,
    pub(crate) effect_pool: ResourceIdVec,
}
impl ItemBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn id(mut self, v: ResourceId) -> Self {
        self.id = v;
        self
    }
    pub fn class(mut self, v: Byte) -> Self {
        self.class = v;
        self
    }
    pub fn quality(mut self, v: Byte) -> Self {
        self.quality = v;
        self
    }
    pub fn random_weight(mut self, v: RandomByte) -> Self {
        self.random_weight = v;
        self
    }
    pub fn price(mut self, v: RandomNumber) -> Self {
        self.price = v;
        self
    }
    pub fn effect_pool(mut self, v: ResourceIdVec) -> Self {
        self.effect_pool = v;
        self
    }
}
impl molecule::prelude::Builder for ItemBuilder {
    type Entity = Item;
    const NAME: &'static str = "ItemBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.class.as_slice().len()
            + self.quality.as_slice().len()
            + self.random_weight.as_slice().len()
            + self.price.as_slice().len()
            + self.effect_pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.class.as_slice().len();
        offsets.push(total_size);
        total_size += self.quality.as_slice().len();
        offsets.push(total_size);
        total_size += self.random_weight.as_slice().len();
        offsets.push(total_size);
        total_size += self.price.as_slice().len();
        offsets.push(total_size);
        total_size += self.effect_pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.class.as_slice())?;
        writer.write_all(self.quality.as_slice())?;
        writer.write_all(self.random_weight.as_slice())?;
        writer.write_all(self.price.as_slice())?;
        writer.write_all(self.effect_pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Item::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ItemVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ItemVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ItemVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ItemVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for ItemVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ItemVec::new_unchecked(v)
    }
}
impl ItemVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Item> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Item {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Item::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Item::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ItemVecReader<'r> {
        ItemVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ItemVec {
    type Builder = ItemVecBuilder;
    const NAME: &'static str = "ItemVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ItemVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ItemVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ItemVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct ItemVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ItemVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ItemVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ItemVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ItemVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ItemReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ItemReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            ItemReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            ItemReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ItemVecReader<'r> {
    type Entity = ItemVec;
    const NAME: &'static str = "ItemVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ItemVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            ItemReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ItemVecBuilder(pub(crate) Vec<Item>);
impl ItemVecBuilder {
    pub fn set(mut self, v: Vec<Item>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Item) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Item>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Item) -> Option<Item> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for ItemVecBuilder {
    type Entity = ItemVec;
    const NAME: &'static str = "ItemVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ItemVec::new_unchecked(inner.into())
    }
}
pub struct ItemVecIterator(ItemVec, usize, usize);
impl ::core::iter::Iterator for ItemVecIterator {
    type Item = Item;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for ItemVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for ItemVec {
    type Item = Item;
    type IntoIter = ItemVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        ItemVecIterator(self, 0, len)
    }
}
impl<'r> ItemVecReader<'r> {
    pub fn iter<'t>(&'t self) -> ItemVecReaderIterator<'t, 'r> {
        ItemVecReaderIterator(&self, 0, self.len())
    }
}
pub struct ItemVecReaderIterator<'t, 'r>(&'t ItemVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for ItemVecReaderIterator<'t, 'r> {
    type Item = ItemReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for ItemVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Action(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "random", self.random())?;
        write!(f, ", {}: {}", "effect_pool", self.effect_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Action {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Action::new_unchecked(v)
    }
}
impl Action {
    const DEFAULT_VALUE: [u8; 23] = [
        23, 0, 0, 0, 16, 0, 0, 0, 18, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceId {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceId::new_unchecked(self.0.slice(start..end))
    }
    pub fn random(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn effect_pool(&self) -> ResourceIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            ResourceIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ResourceIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ActionReader<'r> {
        ActionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Action {
    type Builder = ActionBuilder;
    const NAME: &'static str = "Action";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Action(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .id(self.id())
            .random(self.random())
            .effect_pool(self.effect_pool())
    }
}
#[derive(Clone, Copy)]
pub struct ActionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "random", self.random())?;
        write!(f, ", {}: {}", "effect_pool", self.effect_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ActionReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceIdReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceIdReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn random(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn effect_pool(&self) -> ResourceIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ActionReader<'r> {
    type Entity = Action;
    const NAME: &'static str = "ActionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ActionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ResourceIdReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ResourceIdVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ActionBuilder {
    pub(crate) id: ResourceId,
    pub(crate) random: Byte,
    pub(crate) effect_pool: ResourceIdVec,
}
impl ActionBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn id(mut self, v: ResourceId) -> Self {
        self.id = v;
        self
    }
    pub fn random(mut self, v: Byte) -> Self {
        self.random = v;
        self
    }
    pub fn effect_pool(mut self, v: ResourceIdVec) -> Self {
        self.effect_pool = v;
        self
    }
}
impl molecule::prelude::Builder for ActionBuilder {
    type Entity = Action;
    const NAME: &'static str = "ActionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.random.as_slice().len()
            + self.effect_pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.random.as_slice().len();
        offsets.push(total_size);
        total_size += self.effect_pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.random.as_slice())?;
        writer.write_all(self.effect_pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Action::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ActionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ActionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ActionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ActionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for ActionVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ActionVec::new_unchecked(v)
    }
}
impl ActionVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Action> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Action {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Action::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Action::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ActionVecReader<'r> {
        ActionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ActionVec {
    type Builder = ActionVecBuilder;
    const NAME: &'static str = "ActionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ActionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct ActionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ActionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ActionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ActionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ActionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ActionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ActionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            ActionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            ActionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ActionVecReader<'r> {
    type Entity = ActionVec;
    const NAME: &'static str = "ActionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ActionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            ActionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ActionVecBuilder(pub(crate) Vec<Action>);
impl ActionVecBuilder {
    pub fn set(mut self, v: Vec<Action>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Action) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Action>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Action) -> Option<Action> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for ActionVecBuilder {
    type Entity = ActionVec;
    const NAME: &'static str = "ActionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ActionVec::new_unchecked(inner.into())
    }
}
pub struct ActionVecIterator(ActionVec, usize, usize);
impl ::core::iter::Iterator for ActionVecIterator {
    type Item = Action;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for ActionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for ActionVec {
    type Item = Action;
    type IntoIter = ActionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        ActionVecIterator(self, 0, len)
    }
}
impl<'r> ActionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> ActionVecReaderIterator<'t, 'r> {
        ActionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct ActionVecReaderIterator<'t, 'r>(&'t ActionVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for ActionVecReaderIterator<'t, 'r> {
    type Item = ActionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for ActionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Package(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Package {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Package {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Package {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "size", self.size())?;
        write!(f, ", {}: {}", "item_pool", self.item_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Package {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Package::new_unchecked(v)
    }
}
impl Package {
    const DEFAULT_VALUE: [u8; 17] = [17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn size(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn item_pool(&self) -> ResourceIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ResourceIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ResourceIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PackageReader<'r> {
        PackageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Package {
    type Builder = PackageBuilder;
    const NAME: &'static str = "Package";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Package(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PackageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PackageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .size(self.size())
            .item_pool(self.item_pool())
    }
}
#[derive(Clone, Copy)]
pub struct PackageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PackageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PackageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PackageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "size", self.size())?;
        write!(f, ", {}: {}", "item_pool", self.item_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> PackageReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn size(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn item_pool(&self) -> ResourceIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PackageReader<'r> {
    type Entity = Package;
    const NAME: &'static str = "PackageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PackageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ResourceIdVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PackageBuilder {
    pub(crate) size: Byte,
    pub(crate) item_pool: ResourceIdVec,
}
impl PackageBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn size(mut self, v: Byte) -> Self {
        self.size = v;
        self
    }
    pub fn item_pool(mut self, v: ResourceIdVec) -> Self {
        self.item_pool = v;
        self
    }
}
impl molecule::prelude::Builder for PackageBuilder {
    type Entity = Package;
    const NAME: &'static str = "PackageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.size.as_slice().len()
            + self.item_pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.size.as_slice().len();
        offsets.push(total_size);
        total_size += self.item_pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.size.as_slice())?;
        writer.write_all(self.item_pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Package::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct PackageOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PackageOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PackageOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PackageOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for PackageOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PackageOpt::new_unchecked(v)
    }
}
impl PackageOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Package> {
        if self.is_none() {
            None
        } else {
            Some(Package::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PackageOptReader<'r> {
        PackageOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PackageOpt {
    type Builder = PackageOptBuilder;
    const NAME: &'static str = "PackageOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PackageOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PackageOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PackageOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct PackageOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PackageOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PackageOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PackageOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> PackageOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<PackageReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(PackageReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PackageOptReader<'r> {
    type Entity = PackageOpt;
    const NAME: &'static str = "PackageOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PackageOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            PackageReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PackageOptBuilder(pub(crate) Option<Package>);
impl PackageOptBuilder {
    pub fn set(mut self, v: Option<Package>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for PackageOptBuilder {
    type Entity = PackageOpt;
    const NAME: &'static str = "PackageOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PackageOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Score(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Score {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Score {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Score {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Score {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Score::new_unchecked(v)
    }
}
impl Score {
    const DEFAULT_VALUE: [u8; 27] = [
        0, 0, 0, 0, 23, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ScoreUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Context::new_unchecked(inner).into(),
            1 => RandomNumber::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> ScoreReader<'r> {
        ScoreReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Score {
    type Builder = ScoreBuilder;
    const NAME: &'static str = "Score";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Score(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScoreReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScoreReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct ScoreReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ScoreReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ScoreReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ScoreReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> ScoreReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ScoreUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ContextReader::new_unchecked(inner).into(),
            1 => RandomNumberReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ScoreReader<'r> {
    type Entity = Score;
    const NAME: &'static str = "ScoreReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ScoreReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ContextReader::verify(inner_slice, compatible),
            1 => RandomNumberReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ScoreBuilder(pub(crate) ScoreUnion);
impl ScoreBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<ScoreUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for ScoreBuilder {
    type Entity = Score;
    const NAME: &'static str = "ScoreBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Score::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum ScoreUnion {
    Context(Context),
    RandomNumber(RandomNumber),
}
#[derive(Debug, Clone, Copy)]
pub enum ScoreUnionReader<'r> {
    Context(ContextReader<'r>),
    RandomNumber(RandomNumberReader<'r>),
}
impl ::core::default::Default for ScoreUnion {
    fn default() -> Self {
        ScoreUnion::Context(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for ScoreUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ScoreUnion::Context(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Context::NAME, item)
            }
            ScoreUnion::RandomNumber(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RandomNumber::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for ScoreUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ScoreUnionReader::Context(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Context::NAME, item)
            }
            ScoreUnionReader::RandomNumber(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RandomNumber::NAME, item)
            }
        }
    }
}
impl ScoreUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ScoreUnion::Context(ref item) => write!(f, "{}", item),
            ScoreUnion::RandomNumber(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> ScoreUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ScoreUnionReader::Context(ref item) => write!(f, "{}", item),
            ScoreUnionReader::RandomNumber(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Context> for ScoreUnion {
    fn from(item: Context) -> Self {
        ScoreUnion::Context(item)
    }
}
impl ::core::convert::From<RandomNumber> for ScoreUnion {
    fn from(item: RandomNumber) -> Self {
        ScoreUnion::RandomNumber(item)
    }
}
impl<'r> ::core::convert::From<ContextReader<'r>> for ScoreUnionReader<'r> {
    fn from(item: ContextReader<'r>) -> Self {
        ScoreUnionReader::Context(item)
    }
}
impl<'r> ::core::convert::From<RandomNumberReader<'r>> for ScoreUnionReader<'r> {
    fn from(item: RandomNumberReader<'r>) -> Self {
        ScoreUnionReader::RandomNumber(item)
    }
}
impl ScoreUnion {
    pub const NAME: &'static str = "ScoreUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            ScoreUnion::Context(item) => item.as_bytes(),
            ScoreUnion::RandomNumber(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            ScoreUnion::Context(item) => item.as_slice(),
            ScoreUnion::RandomNumber(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ScoreUnion::Context(_) => 0,
            ScoreUnion::RandomNumber(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ScoreUnion::Context(_) => "Context",
            ScoreUnion::RandomNumber(_) => "RandomNumber",
        }
    }
    pub fn as_reader<'r>(&'r self) -> ScoreUnionReader<'r> {
        match self {
            ScoreUnion::Context(item) => item.as_reader().into(),
            ScoreUnion::RandomNumber(item) => item.as_reader().into(),
        }
    }
}
impl<'r> ScoreUnionReader<'r> {
    pub const NAME: &'r str = "ScoreUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            ScoreUnionReader::Context(item) => item.as_slice(),
            ScoreUnionReader::RandomNumber(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ScoreUnionReader::Context(_) => 0,
            ScoreUnionReader::RandomNumber(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ScoreUnionReader::Context(_) => "Context",
            ScoreUnionReader::RandomNumber(_) => "RandomNumber",
        }
    }
}
#[derive(Clone)]
pub struct Loot(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Loot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Loot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Loot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "score", self.score())?;
        write!(f, ", {}: {}", "card_pool", self.card_pool())?;
        write!(f, ", {}: {}", "props_pool", self.props_pool())?;
        write!(f, ", {}: {}", "equipment_pool", self.equipment_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Loot {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Loot::new_unchecked(v)
    }
}
impl Loot {
    const DEFAULT_VALUE: [u8; 90] = [
        90, 0, 0, 0, 28, 0, 0, 0, 30, 0, 0, 0, 46, 0, 0, 0, 73, 0, 0, 0, 90, 0, 0, 0, 90, 0, 0, 0,
        0, 0, 16, 0, 0, 0, 12, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 16, 0, 0,
        0, 17, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0,
        0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceId {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceId::new_unchecked(self.0.slice(start..end))
    }
    pub fn gold(&self) -> RandomNumber {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        RandomNumber::new_unchecked(self.0.slice(start..end))
    }
    pub fn score(&self) -> Score {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Score::new_unchecked(self.0.slice(start..end))
    }
    pub fn card_pool(&self) -> Package {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Package::new_unchecked(self.0.slice(start..end))
    }
    pub fn props_pool(&self) -> PackageOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        PackageOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn equipment_pool(&self) -> PackageOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PackageOpt::new_unchecked(self.0.slice(start..end))
        } else {
            PackageOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> LootReader<'r> {
        LootReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Loot {
    type Builder = LootBuilder;
    const NAME: &'static str = "Loot";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Loot(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LootReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LootReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .id(self.id())
            .gold(self.gold())
            .score(self.score())
            .card_pool(self.card_pool())
            .props_pool(self.props_pool())
            .equipment_pool(self.equipment_pool())
    }
}
#[derive(Clone, Copy)]
pub struct LootReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LootReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LootReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LootReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "score", self.score())?;
        write!(f, ", {}: {}", "card_pool", self.card_pool())?;
        write!(f, ", {}: {}", "props_pool", self.props_pool())?;
        write!(f, ", {}: {}", "equipment_pool", self.equipment_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> LootReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceIdReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceIdReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn gold(&self) -> RandomNumberReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        RandomNumberReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn score(&self) -> ScoreReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ScoreReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn card_pool(&self) -> PackageReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        PackageReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn props_pool(&self) -> PackageOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        PackageOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn equipment_pool(&self) -> PackageOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PackageOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PackageOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for LootReader<'r> {
    type Entity = Loot;
    const NAME: &'static str = "LootReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LootReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ResourceIdReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        RandomNumberReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ScoreReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        PackageReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        PackageOptReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        PackageOptReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct LootBuilder {
    pub(crate) id: ResourceId,
    pub(crate) gold: RandomNumber,
    pub(crate) score: Score,
    pub(crate) card_pool: Package,
    pub(crate) props_pool: PackageOpt,
    pub(crate) equipment_pool: PackageOpt,
}
impl LootBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn id(mut self, v: ResourceId) -> Self {
        self.id = v;
        self
    }
    pub fn gold(mut self, v: RandomNumber) -> Self {
        self.gold = v;
        self
    }
    pub fn score(mut self, v: Score) -> Self {
        self.score = v;
        self
    }
    pub fn card_pool(mut self, v: Package) -> Self {
        self.card_pool = v;
        self
    }
    pub fn props_pool(mut self, v: PackageOpt) -> Self {
        self.props_pool = v;
        self
    }
    pub fn equipment_pool(mut self, v: PackageOpt) -> Self {
        self.equipment_pool = v;
        self
    }
}
impl molecule::prelude::Builder for LootBuilder {
    type Entity = Loot;
    const NAME: &'static str = "LootBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.gold.as_slice().len()
            + self.score.as_slice().len()
            + self.card_pool.as_slice().len()
            + self.props_pool.as_slice().len()
            + self.equipment_pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.gold.as_slice().len();
        offsets.push(total_size);
        total_size += self.score.as_slice().len();
        offsets.push(total_size);
        total_size += self.card_pool.as_slice().len();
        offsets.push(total_size);
        total_size += self.props_pool.as_slice().len();
        offsets.push(total_size);
        total_size += self.equipment_pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.gold.as_slice())?;
        writer.write_all(self.score.as_slice())?;
        writer.write_all(self.card_pool.as_slice())?;
        writer.write_all(self.props_pool.as_slice())?;
        writer.write_all(self.equipment_pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Loot::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct LootVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LootVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LootVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LootVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for LootVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        LootVec::new_unchecked(v)
    }
}
impl LootVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Loot> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Loot {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Loot::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Loot::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> LootVecReader<'r> {
        LootVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LootVec {
    type Builder = LootVecBuilder;
    const NAME: &'static str = "LootVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LootVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LootVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LootVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct LootVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LootVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LootVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LootVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> LootVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<LootReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> LootReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            LootReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            LootReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for LootVecReader<'r> {
    type Entity = LootVec;
    const NAME: &'static str = "LootVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LootVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            LootReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct LootVecBuilder(pub(crate) Vec<Loot>);
impl LootVecBuilder {
    pub fn set(mut self, v: Vec<Loot>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Loot) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Loot>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Loot) -> Option<Loot> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for LootVecBuilder {
    type Entity = LootVec;
    const NAME: &'static str = "LootVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LootVec::new_unchecked(inner.into())
    }
}
pub struct LootVecIterator(LootVec, usize, usize);
impl ::core::iter::Iterator for LootVecIterator {
    type Item = Loot;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for LootVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for LootVec {
    type Item = Loot;
    type IntoIter = LootVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        LootVecIterator(self, 0, len)
    }
}
impl<'r> LootVecReader<'r> {
    pub fn iter<'t>(&'t self) -> LootVecReaderIterator<'t, 'r> {
        LootVecReaderIterator(&self, 0, self.len())
    }
}
pub struct LootVecReaderIterator<'t, 'r>(&'t LootVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for LootVecReaderIterator<'t, 'r> {
    type Item = LootReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for LootVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct PotionAlchemy(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PotionAlchemy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PotionAlchemy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PotionAlchemy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "hp", self.hp())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "power", self.power())?;
        write!(f, ", {}: {}", "motion", self.motion())?;
        write!(f, ", {}: {}", "view_range", self.view_range())?;
        write!(f, ", {}: {}", "armor", self.armor())?;
        write!(f, ", {}: {}", "shield", self.shield())?;
        write!(f, ", {}: {}", "attack", self.attack())?;
        write!(f, ", {}: {}", "defense", self.defense())?;
        write!(f, ", {}: {}", "physique", self.physique())?;
        write!(f, ", {}: {}", "draw_count", self.draw_count())?;
        write!(f, ", {}: {}", "deck_size", self.deck_size())?;
        write!(f, ", {}: {}", "deck_status", self.deck_status())?;
        write!(f, ", {}: {}", "package_size", self.package_size())?;
        write!(f, ", {}: {}", "package_status", self.package_status())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for PotionAlchemy {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PotionAlchemy::new_unchecked(v)
    }
}
impl PotionAlchemy {
    const DEFAULT_VALUE: [u8; 234] = [
        234, 0, 0, 0, 68, 0, 0, 0, 70, 0, 0, 0, 84, 0, 0, 0, 98, 0, 0, 0, 112, 0, 0, 0, 126, 0, 0,
        0, 140, 0, 0, 0, 154, 0, 0, 0, 168, 0, 0, 0, 182, 0, 0, 0, 196, 0, 0, 0, 210, 0, 0, 0, 224,
        0, 0, 0, 225, 0, 0, 0, 229, 0, 0, 0, 230, 0, 0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 16;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceId {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceId::new_unchecked(self.0.slice(start..end))
    }
    pub fn hp(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn gold(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn power(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn motion(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn view_range(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn armor(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn shield(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn attack(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn defense(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn physique(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn draw_count(&self) -> RandomByte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        RandomByte::new_unchecked(self.0.slice(start..end))
    }
    pub fn deck_size(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn deck_status(&self) -> ResourceIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        let end = molecule::unpack_number(&slice[60..]) as usize;
        ResourceIdVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn package_size(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[60..]) as usize;
        let end = molecule::unpack_number(&slice[64..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn package_status(&self) -> ResourceIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[64..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[68..]) as usize;
            ResourceIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ResourceIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PotionAlchemyReader<'r> {
        PotionAlchemyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PotionAlchemy {
    type Builder = PotionAlchemyBuilder;
    const NAME: &'static str = "PotionAlchemy";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PotionAlchemy(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PotionAlchemyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PotionAlchemyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .id(self.id())
            .hp(self.hp())
            .gold(self.gold())
            .power(self.power())
            .motion(self.motion())
            .view_range(self.view_range())
            .armor(self.armor())
            .shield(self.shield())
            .attack(self.attack())
            .defense(self.defense())
            .physique(self.physique())
            .draw_count(self.draw_count())
            .deck_size(self.deck_size())
            .deck_status(self.deck_status())
            .package_size(self.package_size())
            .package_status(self.package_status())
    }
}
#[derive(Clone, Copy)]
pub struct PotionAlchemyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PotionAlchemyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PotionAlchemyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PotionAlchemyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "hp", self.hp())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "power", self.power())?;
        write!(f, ", {}: {}", "motion", self.motion())?;
        write!(f, ", {}: {}", "view_range", self.view_range())?;
        write!(f, ", {}: {}", "armor", self.armor())?;
        write!(f, ", {}: {}", "shield", self.shield())?;
        write!(f, ", {}: {}", "attack", self.attack())?;
        write!(f, ", {}: {}", "defense", self.defense())?;
        write!(f, ", {}: {}", "physique", self.physique())?;
        write!(f, ", {}: {}", "draw_count", self.draw_count())?;
        write!(f, ", {}: {}", "deck_size", self.deck_size())?;
        write!(f, ", {}: {}", "deck_status", self.deck_status())?;
        write!(f, ", {}: {}", "package_size", self.package_size())?;
        write!(f, ", {}: {}", "package_status", self.package_status())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> PotionAlchemyReader<'r> {
    pub const FIELD_COUNT: usize = 16;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> ResourceIdReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ResourceIdReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn hp(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn gold(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn power(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn motion(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn view_range(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn armor(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn shield(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn attack(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn defense(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn physique(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn draw_count(&self) -> RandomByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        RandomByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn deck_size(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn deck_status(&self) -> ResourceIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        let end = molecule::unpack_number(&slice[60..]) as usize;
        ResourceIdVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn package_size(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[60..]) as usize;
        let end = molecule::unpack_number(&slice[64..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn package_status(&self) -> ResourceIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[64..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[68..]) as usize;
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ResourceIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PotionAlchemyReader<'r> {
    type Entity = PotionAlchemy;
    const NAME: &'static str = "PotionAlchemyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PotionAlchemyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ResourceIdReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        RandomByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        RandomByteReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        RandomByteReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        RandomByteReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        RandomByteReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        RandomByteReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        RandomByteReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        RandomByteReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        RandomByteReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        RandomByteReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        RandomByteReader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        ByteReader::verify(&slice[offsets[12]..offsets[13]], compatible)?;
        ResourceIdVecReader::verify(&slice[offsets[13]..offsets[14]], compatible)?;
        ByteReader::verify(&slice[offsets[14]..offsets[15]], compatible)?;
        ResourceIdVecReader::verify(&slice[offsets[15]..offsets[16]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PotionAlchemyBuilder {
    pub(crate) id: ResourceId,
    pub(crate) hp: RandomByte,
    pub(crate) gold: RandomByte,
    pub(crate) power: RandomByte,
    pub(crate) motion: RandomByte,
    pub(crate) view_range: RandomByte,
    pub(crate) armor: RandomByte,
    pub(crate) shield: RandomByte,
    pub(crate) attack: RandomByte,
    pub(crate) defense: RandomByte,
    pub(crate) physique: RandomByte,
    pub(crate) draw_count: RandomByte,
    pub(crate) deck_size: Byte,
    pub(crate) deck_status: ResourceIdVec,
    pub(crate) package_size: Byte,
    pub(crate) package_status: ResourceIdVec,
}
impl PotionAlchemyBuilder {
    pub const FIELD_COUNT: usize = 16;
    pub fn id(mut self, v: ResourceId) -> Self {
        self.id = v;
        self
    }
    pub fn hp(mut self, v: RandomByte) -> Self {
        self.hp = v;
        self
    }
    pub fn gold(mut self, v: RandomByte) -> Self {
        self.gold = v;
        self
    }
    pub fn power(mut self, v: RandomByte) -> Self {
        self.power = v;
        self
    }
    pub fn motion(mut self, v: RandomByte) -> Self {
        self.motion = v;
        self
    }
    pub fn view_range(mut self, v: RandomByte) -> Self {
        self.view_range = v;
        self
    }
    pub fn armor(mut self, v: RandomByte) -> Self {
        self.armor = v;
        self
    }
    pub fn shield(mut self, v: RandomByte) -> Self {
        self.shield = v;
        self
    }
    pub fn attack(mut self, v: RandomByte) -> Self {
        self.attack = v;
        self
    }
    pub fn defense(mut self, v: RandomByte) -> Self {
        self.defense = v;
        self
    }
    pub fn physique(mut self, v: RandomByte) -> Self {
        self.physique = v;
        self
    }
    pub fn draw_count(mut self, v: RandomByte) -> Self {
        self.draw_count = v;
        self
    }
    pub fn deck_size(mut self, v: Byte) -> Self {
        self.deck_size = v;
        self
    }
    pub fn deck_status(mut self, v: ResourceIdVec) -> Self {
        self.deck_status = v;
        self
    }
    pub fn package_size(mut self, v: Byte) -> Self {
        self.package_size = v;
        self
    }
    pub fn package_status(mut self, v: ResourceIdVec) -> Self {
        self.package_status = v;
        self
    }
}
impl molecule::prelude::Builder for PotionAlchemyBuilder {
    type Entity = PotionAlchemy;
    const NAME: &'static str = "PotionAlchemyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.hp.as_slice().len()
            + self.gold.as_slice().len()
            + self.power.as_slice().len()
            + self.motion.as_slice().len()
            + self.view_range.as_slice().len()
            + self.armor.as_slice().len()
            + self.shield.as_slice().len()
            + self.attack.as_slice().len()
            + self.defense.as_slice().len()
            + self.physique.as_slice().len()
            + self.draw_count.as_slice().len()
            + self.deck_size.as_slice().len()
            + self.deck_status.as_slice().len()
            + self.package_size.as_slice().len()
            + self.package_status.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.hp.as_slice().len();
        offsets.push(total_size);
        total_size += self.gold.as_slice().len();
        offsets.push(total_size);
        total_size += self.power.as_slice().len();
        offsets.push(total_size);
        total_size += self.motion.as_slice().len();
        offsets.push(total_size);
        total_size += self.view_range.as_slice().len();
        offsets.push(total_size);
        total_size += self.armor.as_slice().len();
        offsets.push(total_size);
        total_size += self.shield.as_slice().len();
        offsets.push(total_size);
        total_size += self.attack.as_slice().len();
        offsets.push(total_size);
        total_size += self.defense.as_slice().len();
        offsets.push(total_size);
        total_size += self.physique.as_slice().len();
        offsets.push(total_size);
        total_size += self.draw_count.as_slice().len();
        offsets.push(total_size);
        total_size += self.deck_size.as_slice().len();
        offsets.push(total_size);
        total_size += self.deck_status.as_slice().len();
        offsets.push(total_size);
        total_size += self.package_size.as_slice().len();
        offsets.push(total_size);
        total_size += self.package_status.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.hp.as_slice())?;
        writer.write_all(self.gold.as_slice())?;
        writer.write_all(self.power.as_slice())?;
        writer.write_all(self.motion.as_slice())?;
        writer.write_all(self.view_range.as_slice())?;
        writer.write_all(self.armor.as_slice())?;
        writer.write_all(self.shield.as_slice())?;
        writer.write_all(self.attack.as_slice())?;
        writer.write_all(self.defense.as_slice())?;
        writer.write_all(self.physique.as_slice())?;
        writer.write_all(self.draw_count.as_slice())?;
        writer.write_all(self.deck_size.as_slice())?;
        writer.write_all(self.deck_status.as_slice())?;
        writer.write_all(self.package_size.as_slice())?;
        writer.write_all(self.package_status.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PotionAlchemy::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct PotionAlchemyVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PotionAlchemyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PotionAlchemyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PotionAlchemyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for PotionAlchemyVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PotionAlchemyVec::new_unchecked(v)
    }
}
impl PotionAlchemyVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<PotionAlchemy> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> PotionAlchemy {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            PotionAlchemy::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            PotionAlchemy::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PotionAlchemyVecReader<'r> {
        PotionAlchemyVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PotionAlchemyVec {
    type Builder = PotionAlchemyVecBuilder;
    const NAME: &'static str = "PotionAlchemyVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PotionAlchemyVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PotionAlchemyVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PotionAlchemyVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct PotionAlchemyVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PotionAlchemyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PotionAlchemyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PotionAlchemyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> PotionAlchemyVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<PotionAlchemyReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> PotionAlchemyReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            PotionAlchemyReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            PotionAlchemyReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PotionAlchemyVecReader<'r> {
    type Entity = PotionAlchemyVec;
    const NAME: &'static str = "PotionAlchemyVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PotionAlchemyVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            PotionAlchemyReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PotionAlchemyVecBuilder(pub(crate) Vec<PotionAlchemy>);
impl PotionAlchemyVecBuilder {
    pub fn set(mut self, v: Vec<PotionAlchemy>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: PotionAlchemy) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = PotionAlchemy>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: PotionAlchemy) -> Option<PotionAlchemy> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for PotionAlchemyVecBuilder {
    type Entity = PotionAlchemyVec;
    const NAME: &'static str = "PotionAlchemyVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PotionAlchemyVec::new_unchecked(inner.into())
    }
}
pub struct PotionAlchemyVecIterator(PotionAlchemyVec, usize, usize);
impl ::core::iter::Iterator for PotionAlchemyVecIterator {
    type Item = PotionAlchemy;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for PotionAlchemyVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for PotionAlchemyVec {
    type Item = PotionAlchemy;
    type IntoIter = PotionAlchemyVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        PotionAlchemyVecIterator(self, 0, len)
    }
}
impl<'r> PotionAlchemyVecReader<'r> {
    pub fn iter<'t>(&'t self) -> PotionAlchemyVecReaderIterator<'t, 'r> {
        PotionAlchemyVecReaderIterator(&self, 0, self.len())
    }
}
pub struct PotionAlchemyVecReaderIterator<'t, 'r>(&'t PotionAlchemyVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for PotionAlchemyVecReaderIterator<'t, 'r> {
    type Item = PotionAlchemyReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for PotionAlchemyVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
